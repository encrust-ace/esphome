- random:
- addressable_fireworks:
- addressable_twinkle:
- addressable_scan:
- addressable_color_wipe:
- addressable_rainbow:
- addressable_lambda:
    name: "Diya Flicker"
    update_interval: 16ms
    lambda: |-
      float animation_period_ms = 10000.0;
      float time_progress = fmod((float)millis(), animation_period_ms) / animation_period_ms;
      float time_phase = time_progress * M_PI * 2.0;

      Color base_flame_color = Color(255, 100, 0);
      Color peak_flame_color = Color(255, 255, 200);

      int base_glow_leds = 3;

      float global_flicker_speed = 4.0;
      float per_led_flicker_speed = 8.0;
      float min_brightness_factor = 0.3;
      float max_brightness_factor = 1.0;
      float random_flicker_strength = 0.2;

      float global_flicker = (sin(time_phase * global_flicker_speed) + 1.0f) / 2.0f;

      auto blend = [](uint8_t a, uint8_t b, float t) -> uint8_t {
        return static_cast<uint8_t>(a + (b - a) * t);
      };

      for (int i = 0; i < it.size(); i++) {
        Color current_led_color;
        float current_brightness_factor;

        if (i < base_glow_leds) {
          current_led_color = base_flame_color;
          current_brightness_factor = 1.0;
        } else {
          float per_led_flicker = (sin(time_phase * per_led_flicker_speed + i * 0.5f) + 1.0f) / 2.0f;
          float combined_flicker = global_flicker * 0.7f + per_led_flicker * 0.3f;

          float random_val = (float)esphome::random_uint32() / (float)UINT32_MAX;
          combined_flicker += (random_val - 0.5f) * random_flicker_strength;
          combined_flicker = esphome::clamp(combined_flicker, 0.0f, 1.0f);

          current_brightness_factor = min_brightness_factor + 
            (max_brightness_factor - min_brightness_factor) * combined_flicker;

          float height_progress = (float)(i - base_glow_leds) / (it.size() - 1.0f - base_glow_leds);
          height_progress = esphome::clamp(height_progress, 0.0f, 1.0f);

          current_led_color = Color(
            blend(base_flame_color.r, peak_flame_color.r, height_progress),
            blend(base_flame_color.g, peak_flame_color.g, height_progress),
            blend(base_flame_color.b, peak_flame_color.b, height_progress)
          );
        }

        it[i] = Color(
          static_cast<uint8_t>(current_led_color.r * current_brightness_factor),
          static_cast<uint8_t>(current_led_color.g * current_brightness_factor),
          static_cast<uint8_t>(current_led_color.b * current_brightness_factor)
        );
      }

- addressable_lambda:
    name: "Siri Glow"
    lambda: |-
      static std::vector<Color> siri_colors = {
        Color(0, 255, 255),
        Color(138, 43, 226),
        Color(255, 105, 180)
      };

      int num_segments = siri_colors.size();
      int segment_len = it.size() / num_segments;

      auto blend_color = [](const Color &a, const Color &b, float t) -> Color {
        return Color(
          static_cast<uint8_t>(a.r + (b.r - a.r) * t),
          static_cast<uint8_t>(a.g + (b.g - a.g) * t),
          static_cast<uint8_t>(a.b + (b.b - a.b) * t)
        );
      };

      for (int i = 0; i < it.size(); i++) {
        int segment = i / segment_len;
        int next_segment = (segment + 1) % siri_colors.size();
        float local_pos = (i % segment_len) / float(segment_len);
        Color color = blend_color(siri_colors[segment], siri_colors[next_segment], local_pos);
        it[i] = color;
      }

- addressable_lambda:
    name: "Drip"
    update_interval: 16ms
    lambda: |-
      struct Drop {
        float pos;
        float vel;
        uint16_t col;
        uint8_t col_index;
      };

      static const int max_drops = 4;
      static Drop drops[max_drops];

      float gravity = -0.0005f - (128.0f / 50000.0f);  // Approximate SEGMENT.speed = 128
      gravity *= std::max(1.0f, float(it.size() - 1));
      const int sourcedrop = 12;

      Color base_color = current_color;
      it.all() = Color(0, 0, 0);
      int seglen = it.size();

      for (int j = 0; j < max_drops; j++) {
        if (drops[j].col_index == 0) {
          drops[j].pos = seglen - 1;
          drops[j].vel = 0;
          drops[j].col = sourcedrop;
          drops[j].col_index = 1;
        }

        int src_idx = seglen - 1;
        it[src_idx] = base_color.fade_to_black(255 - sourcedrop);

        if (drops[j].col_index == 1) {
          if (drops[j].col > 255) drops[j].col = 255;
          int p = int(drops[j].pos);
          if (p >= 0 && p < seglen)
            it[p] = base_color.fade_to_black(255 - drops[j].col);

          drops[j].col += 2;

          if ((esphome::random_uint32() % 256) < drops[j].col / 10) {
            drops[j].col_index = 2;
            drops[j].col = 255;
          }
        }

        if (drops[j].col_index > 1) {
          if (drops[j].pos > 0) {
            drops[j].pos += drops[j].vel;
            if (drops[j].pos < 0) drops[j].pos = 0;
            drops[j].vel += gravity;

            for (int i = 1; i < 7 - drops[j].col_index; i++) {
              int pos = int(drops[j].pos + i);
              pos = std::max(0, std::min(pos, seglen - 1));
              it[pos] = base_color.fade_to_black(255 - drops[j].col / i);
            }

            if (drops[j].col_index > 2) {
              it[0] = base_color.fade_to_black(255 - drops[j].col);
            }
          } else {
            if (drops[j].col_index > 2) {
              drops[j].col_index = 0;
              drops[j].col = sourcedrop;
            } else {
              if (drops[j].col_index == 2) {
                drops[j].vel = -drops[j].vel / 4.0f;
                drops[j].pos += drops[j].vel;
              }
              drops[j].col = sourcedrop * 2;
              drops[j].col_index = 5;
            }
          }
        }
      }

- wled:
    name: "UDP Sync"
