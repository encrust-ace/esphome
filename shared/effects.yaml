- random:
- addressable_fireworks:
- addressable_twinkle:
- addressable_scan:
- addressable_color_wipe:
- addressable_rainbow:
- addressable_lambda:
    name: "Siri Glow"
    lambda: |-
      static std::vector<Color> siri_colors = {
        Color(0, 255, 255),
        Color(138, 43, 226),
        Color(255, 105, 180)
      };

      int num_segments = siri_colors.size();
      int segment_len = it.size() / num_segments;

      auto blend_color = [](const Color &a, const Color &b, float t) -> Color {
        return Color(
          static_cast<uint8_t>(a.r + (b.r - a.r) * t),
          static_cast<uint8_t>(a.g + (b.g - a.g) * t),
          static_cast<uint8_t>(a.b + (b.b - a.b) * t)
        );
      };

      for (int i = 0; i < it.size(); i++) {
        int segment = i / segment_len;
        int next_segment = (segment + 1) % siri_colors.size();
        float local_pos = (i % segment_len) / float(segment_len);
        Color color = blend_color(siri_colors[segment], siri_colors[next_segment], local_pos);
        it[i] = color;
      }

- addressable_lambda:
    name: "Drip"
    update_interval: 16ms
    lambda: |-
      struct Drop {
        float pos;
        float vel;
        uint16_t col;
        uint8_t col_index;
      };

      static const int max_drops = 4;
      static Drop drops[max_drops];

      float gravity = -0.0005f - (128.0f / 50000.0f);  // Approximate SEGMENT.speed = 128
      gravity *= std::max(1.0f, float(it.size() - 1));
      const int sourcedrop = 12;

      Color base_color = current_color;
      it.all() = Color(0, 0, 0);
      int seglen = it.size();

      for (int j = 0; j < max_drops; j++) {
        if (drops[j].col_index == 0) {
          drops[j].pos = seglen - 1;
          drops[j].vel = 0;
          drops[j].col = sourcedrop;
          drops[j].col_index = 1;
        }

        int src_idx = seglen - 1;
        it[src_idx] = base_color.fade_to_black(255 - sourcedrop);

        if (drops[j].col_index == 1) {
          if (drops[j].col > 255) drops[j].col = 255;
          int p = int(drops[j].pos);
          if (p >= 0 && p < seglen)
            it[p] = base_color.fade_to_black(255 - drops[j].col);

          drops[j].col += 2;

          if ((esphome::random_uint32() % 256) < drops[j].col / 10) {
            drops[j].col_index = 2;
            drops[j].col = 255;
          }
        }

        if (drops[j].col_index > 1) {
          if (drops[j].pos > 0) {
            drops[j].pos += drops[j].vel;
            if (drops[j].pos < 0) drops[j].pos = 0;
            drops[j].vel += gravity;

            for (int i = 1; i < 7 - drops[j].col_index; i++) {
              int pos = int(drops[j].pos + i);
              pos = std::max(0, std::min(pos, seglen - 1));
              it[pos] = base_color.fade_to_black(255 - drops[j].col / i);
            }

            if (drops[j].col_index > 2) {
              it[0] = base_color.fade_to_black(255 - drops[j].col);
            }
          } else {
            if (drops[j].col_index > 2) {
              drops[j].col_index = 0;
              drops[j].col = sourcedrop;
            } else {
              if (drops[j].col_index == 2) {
                drops[j].vel = -drops[j].vel / 4.0f;
                drops[j].pos += drops[j].vel;
              }
              drops[j].col = sourcedrop * 2;
              drops[j].col_index = 5;
            }
          }
        }
      }

- wled:
    name: "UDP Sync"
