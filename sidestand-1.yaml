esphome:
  name: sidestand-1
  friendly_name: "Sidestand-1"

esp32:
  board: esp32-c3-devkitm-1
  framework: 
    type: arduino
    
bluetooth_proxy:
logger:
api:
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 
    minutes: 2
  ap:
    ssid: "Sidestand-1 Fallback Hotspot"
    password: "12345678"

captive_portal:
web_server:
improv_serial:
wled:

# ========== SENSORS ==========
sensor:
  - platform: wifi_signal
    name: "WiFi Signal (dBm)"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"

  - platform: template
    name: "WiFi Signal"
    unit_of_measurement: "%"
    id: wifi_signal_percent
    update_interval: 60s
    entity_category: "diagnostic"
    icon: "mdi:wifi"
    lambda: |-
      float rssi = id(wifi_signal_db).state;
      float percentage = 2.0 * (rssi + 100.0);
      return std::min(100.0f, std::max(0.0f, percentage));

  - platform: uptime
    name: "Uptime"
    unit_of_measurement: "s"
    entity_category: "diagnostic"

  - platform: template
    name: "Free Heap"
    lambda: 'return (float)ESP.getFreeHeap();'
    unit_of_measurement: "bytes"
    update_interval: 60s
    entity_category: "diagnostic"
    
  - platform: internal_temperature
    name: "ESP Temperature"
    entity_category: "diagnostic"

# ========== TEXT SENSORS ==========
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"
      icon: "mdi:ip-network"
      entity_category: "diagnostic"
    ssid:
      name: "Connected SSID"
      icon: "mdi:wifi"
      entity_category: "diagnostic"
    mac_address:
      name: "MAC Address"
      icon: "mdi:ethernet"
      entity_category: "diagnostic"

# ========== LIGHT ==========
globals:
  - id: current_palette
    type: int
    initial_value: '0'
  
  - id: speed
    type: int
    initial_value: '0'
  
  - id: gradient_offset
    type: float
    initial_value: '0.0f'

  - id: reverse_effect
    type: bool
    initial_value: 'false'

  - id: previous_reverse_state
    type: bool
    initial_value: 'false'

switch:
  - platform: template
    name: "Reverse Effect"
    id: reverse_effect_switch
    icon: "mdi:swap-horizontal"
    turn_on_action:
      - lambda: |-
          id(reverse_effect) = true;
    turn_off_action:
      - lambda: |-
          id(reverse_effect) = false;

select:
  - platform: template
    name: "Palette"
    id: palette_select
    options:
      - Aurora
      - Ocean
      - Fire
      - Neon
      - Forest
      - Sunset
      - Ice
      - Galaxy
      - Sakura
      - Electric
      - Default
    initial_option: "Default"
    set_action: 
      then:
        - lambda: |-
            if (x == "Aurora") { id(current_palette) = 0; }
            else if (x == "Ocean") { id(current_palette) = 1; }
            else if (x == "Fire") { id(current_palette) = 2; }
            else if (x == "Neon") { id(current_palette) = 3; }
            else if (x == "Forest") { id(current_palette) = 4; }
            else if (x == "Sunset") { id(current_palette) = 5; }
            else if (x == "Ice") { id(current_palette) = 6; }
            else if (x == "Galaxy") { id(current_palette) = 7; }
            else if (x == "Sakura") { id(current_palette) = 8; }
            else if (x == "Electric") { id(current_palette) = 9; }
            else { id(current_palette) = 10; }
            
number:
  - platform: template
    name: "Speed"
    id: speed_number
    step: 1
    min_value: 0
    max_value: 10
    set_action: 
      then:
        - lambda: id(speed) = (int)x;

light:
  - platform: neopixelbus
    type: GRB
    variant: WS2812X
    pin: GPIO02
    num_leds: 90
    id: strip_light
    name: "Light"
    restore_mode: RESTORE_DEFAULT_OFF
    effects:
      - addressable_lambda:
          name: "Dynamic Glow"
          update_interval: 25ms
          lambda: |-
            static const uint8_t palettes[10][3][3] = {
              {{0, 255, 127}, {64, 224, 255}, {255, 20, 147}},     // Aurora
              {{0, 119, 190}, {0, 180, 216}, {144, 224, 239}},     // Ocean
              {{220, 20, 60}, {255, 69, 0}, {255, 215, 0}},        // Fire
              {{57, 255, 20}, {255, 0, 150}, {0, 255, 255}},       // Neon
              {{34, 139, 34}, {154, 205, 50}, {255, 255, 224}},    // Forest
              {{255, 94, 77}, {255, 154, 0}, {255, 206, 84}},      // Sunset
              {{176, 224, 230}, {135, 206, 250}, {255, 255, 255}}, // Ice
              {{75, 0, 130}, {123, 104, 238}, {186, 85, 211}},     // Galaxy
              {{255, 182, 193}, {255, 105, 180}, {219, 112, 147}}, // Sakura
              {{0, 255, 0}, {0, 255, 255}, {255, 255, 0}}          // Electric
            };
            
            if (id(previous_reverse_state) != id(reverse_effect)) {
              id(gradient_offset) = 0.0f;
              id(previous_reverse_state) = id(reverse_effect);
            }
            
            int speed_value = id(speed);
            float direction_multiplier = id(reverse_effect) ? -1.0f : 1.0f;
            
            if (speed_value > 0) {
              float speed_factor = (float)speed_value * 0.002f;
              id(gradient_offset) += speed_factor * direction_multiplier;
              while (id(gradient_offset) >= 1.0f) id(gradient_offset) -= 1.0f;
              while (id(gradient_offset) < 0.0f) id(gradient_offset) += 1.0f;
            }
            
            auto blend = [](uint8_t a, uint8_t b, uint8_t t) -> uint8_t {
              return a + (((int)b - (int)a) * t) / 255;
            };
            
            for (int i = 0; i < it.size(); i++) {
              float position = (float)i / (it.size() - 1);
              float color_pos = position + id(gradient_offset);
              
              while (color_pos >= 1.0f) color_pos -= 1.0f;
              while (color_pos < 0.0f) color_pos += 1.0f;
              
              Color final_color;
              
              if (id(current_palette) == 10) {
                final_color = current_color;
              } else {
                int seg = (int)(color_pos * 3.0f);
                int next_seg = (seg + 1) % 3;
                uint8_t blend_factor = (uint8_t)((color_pos * 3.0f - seg) * 255);
                
                uint8_t r1 = palettes[id(current_palette)][seg][0];
                uint8_t g1 = palettes[id(current_palette)][seg][1];
                uint8_t b1 = palettes[id(current_palette)][seg][2];
                
                uint8_t r2 = palettes[id(current_palette)][next_seg][0];
                uint8_t g2 = palettes[id(current_palette)][next_seg][1];
                uint8_t b2 = palettes[id(current_palette)][next_seg][2];
                
                final_color = Color(
                  blend(r1, r2, blend_factor),
                  blend(g1, g2, blend_factor),
                  blend(b1, b2, blend_factor)
                );
              }
              it[i] = final_color;
            }
      - random:
      - addressable_fireworks:
      - addressable_twinkle:
      - addressable_scan:
      - addressable_color_wipe:
      - addressable_rainbow:

  - platform: partition
    name: "Segment 1"
    segments: 
      - id: strip_light
        from: 0
        to: 20
  - platform: partition
    name: "Segment 2"
    segments: 
      - id: strip_light
        from: 21
        to: 42
  - platform: partition
    name: "Segment 3"
    segments: 
      - id: strip_light
        from: 43
        to: 64
  - platform: partition
    name: "Segment 4"
    segments: 
      - id: strip_light
        from: 65
        to: 89